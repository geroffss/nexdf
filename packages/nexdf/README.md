# nexdf

Plug-and-play PDF generation for Next.js with two engines:

- `chromium`: strongest CSS compatibility (Tailwind, advanced layouts), slower startup.
- `native`: built-in fast HTML/CSS renderer (classic classes + HTMX-friendly templates), lower CSS coverage.

## Features

- Ready `/api/pdf` endpoint (via one scaffold command)
- Unlimited placeholders (`{{anyField}}`)
- Two rendering engines (`chromium` and `native`)
- Tailwind-friendly templates for Chromium path
- Fast built-in native path for classic CSS classes
- A4-ready default template
- Fast runtime path: browser prewarm + page pool reuse + template compile cache
- Optional DB template resolver with file-template fallback

## Install

```bash
npm install nexdf
```

## Quick start

1) Scaffold endpoint + template files in your Next.js app root:

```bash
npx nexdf
```

This creates:

- `app/api/pdf/route.ts`
- `templates/pdf/basic.html`
- `templates/pdf/native.html`

2) Ensure Node runtime in route (generated by default):

```ts
import { createPdfRouteHandler } from "nexdf";

export const runtime = "nodejs";

export const POST = createPdfRouteHandler({
  templatesDir: process.cwd() + "/templates/pdf",
  defaultTemplate: "basic.html",
  defaultEngine: "chromium", // or "native"
  poolSize: 2
});
```

3) Call your endpoint:

```bash
curl -X POST http://localhost:3000/api/pdf \
  -H "content-type: application/json" \
  -d '{
    "filename": "invoice.pdf",
    "engine": "native",
    "templateKey": "basic",
    "templatePath": "native.html",
    "data": {
      "title": "Invoice #001",
      "subtitle": "Thanks for your business",
      "fromName": "Acme",
      "fromEmail": "billing@acme.com",
      "toName": "Jane",
      "toEmail": "jane@example.com",
      "summary": "Any placeholder can be added",
      "generatedAt": "2026-02-13"
    }
  }' --output invoice.pdf
```

## Template customization

Edit `templates/pdf/basic.html` and style with Tailwind classes.

Add as many placeholders as you want:

```html
<h1>{{title}}</h1>
<p>{{customerName}}</p>
<p>{{orderId}}</p>
<p>{{anyCustomField}}</p>
```

## API

`POST /api/pdf`

Body:

```json
{
  "filename": "document.pdf",
  "engine": "chromium",
  "templateKey": "basic",
  "templatePath": "basic.html",
  "data": {
    "title": "Any value"
  }
}
```

Engine behavior:

- `chromium`: best for Tailwind and modern CSS features.
- `native`: best for speed with classic class-based CSS (`font-size`, `font-weight`, `color`, `margin-top`, `margin-bottom`, `line-height`, `text-align`).

Recommended pairing:

- `basic.html` + `engine: "chromium"`
- `native.html` + `engine: "native"`

`templateKey` is available when you use a custom template resolver.

Template resolution behavior:

1. If `resolveTemplate` returns HTML, that HTML is rendered.
2. If `resolveTemplate` returns `null`, file-template rendering is used.
3. File-template path is `templatePath` or `defaultTemplate`.

## Runtime requirements

- Next route runtime must be `nodejs`
- Chrome/Chromium must be available only when using `chromium` engine
- Set executable path if needed:

```bash
export PUPPETEER_EXECUTABLE_PATH="/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"
```

## Performance notes

- Prewarms Chromium when route handler is created
- Reuses hot pages via an internal pool (`poolSize`)
- Caches compiled templates with file mtime invalidation
- Native engine skips browser boot and is typically much faster for text/document layouts

Note: true zero cold start is not possible if your hosting platform starts a brand-new container/process.

## Programmatic usage

```ts
import { createPdfRouteHandler, prewarmPdfEngine } from "nexdf";

await prewarmPdfEngine({ poolSize: 2 });

export const POST = createPdfRouteHandler({
  templatesDir: process.cwd() + "/templates/pdf",
  defaultTemplate: "basic.html",
  defaultEngine: "chromium",
  poolSize: 2
});
```

## Database-backed templates

Use `resolveTemplate` to fetch HTML from DB and render server-side:

```ts
export const POST = createPdfRouteHandler({
  templatesDir: process.cwd() + "/templates/pdf",
  defaultTemplate: "basic.html",
  poolSize: 2,
  resolveTemplate: async ({ body }) => {
    const templateKey = body.templateKey ?? "basic";
    const html = await loadTemplateHtmlFromDb(templateKey);
    return html;
  }
});
```

If `resolveTemplate` returns `null`, file-based template loading is used as fallback.

Example request body with DB-first + file fallback support:

```json
{
  "filename": "document.pdf",
  "templateKey": "basic",
  "templatePath": "basic.html",
  "data": {
    "title": "Any value"
  }
}
```